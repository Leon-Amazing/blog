---
title: WebGL
date: 2021-12-20
tags:
  - 数据可视化
categories:
  - frontend
---

## 一、WebGL-介绍

> WebGL（全写 Web Graphics Library）是一种 3D 绘图协议，这种绘图技术标准允许把 JavaScript 和 OpenGL ES 2.0 结合在一起，通过增加 OpenGL ES 2.0 的一个 JavaScript 绑定，WebGL 可以为 HTML5 Canvas 提供硬件 3D 加速渲染，这样 Web 开发人员就可以借助系统显卡来在浏览器里更流畅地展示 3D 场景和模型了，还能创建复杂的导航和数据视觉化。显然，WebGL 技术标准免去了开发网页专用渲染插件的麻烦，可被用于创建具有复杂 3D 结构的网站页面，甚至可以用来设计 3D 网页游戏等等

![](../img/2021/1220/1.png)

## 二、webgl 基础知识

### 1.刷底色

```js
// 在js中获取canvas画布
const canvas = document.querySelector("#canvas");
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;
// 使用canvas 获取webgl 绘图上下文
const gl = canvas.getContext("webgl");
// 指定将要用来清空绘图区的颜色 rgba
gl.clearColor(1, 1, 0, 1);
// 刷底色
gl.clear(gl.COLOR_BUFFER_BIT);
```

**注：clearColor(r,g,b,a) 中的参数是红、绿、蓝、透明度，其定义域是[0,1]**

### 2.webgl 坐标系

> canvas 2d 画布的坐标系  
> canvas 2d 坐标系的原点在左上角  
> canvas 2d 坐标系的 y 轴方向是朝下的  
> canvas 2d 坐标系的坐标基底有两个分量，分别是一个像素的宽和一个像素的高，即 1 个单位的宽便是 1 个像素的宽，1 个单位的高便是一个像素的高

![](../img/2021/1220/2.png)

> webgl 的坐标系  
> webgl 坐标系的坐标原点在画布中心  
> webgl 坐标系的 y 轴方向是朝上的  
> webgl 坐标基底中的两个分量分别是半个 canvas 的宽和 canvas 的高，即 1 个单位的宽便是半个个 canvas 的宽，1 个单位的高便是半个 canvas 的高

![](../img/2021/1220/3.png)

### 3.webgl 画一个点

#### 1) 绘图的基本步骤

1. 找一张画布

2. 找一支画笔

3. 开始画画

**canvas 2d 的绘图逻辑就是如此**

```js
//canvas画布
const canvas = document.getElementById("canvas");
//二维画笔
const ctx = canvas.getContext("2d");
//设置画笔的颜色
ctx.fillStyle = "red";
//用画笔画一个矩形
ctx.fillRect(20, 20, 300, 200);
```

#### 2) canvas 2d 和 webgl 绘图的差异

> 浏览器有三大线程： js 引擎线程、GUI 渲染线程、浏览器事件触发线程  
> GUI 渲染线程就是用于渲图，，在这个渲染线程里，有负责不同渲染工作的工人。比如有负责渲染 HTML+css 的工人，有负责渲染二维图形的工人，有负责渲染三维图形的工人  
> 渲染二维图形的工人说的是 js 语言  
> 渲染三维图形的工人说的是 GLSL ES 语言  
> GLSL ES <=> 程序对象 <=> js

#### 3) webgl 的绘图思路步骤

1. 找一台电脑 - 浏览器里内置的 webgl 渲染引擎，负责渲染 webgl 图形，只认 GLSL ES 语言
2. 找一块手绘板 - 程序对象，承载 GLSL ES 语言，翻译 GLSL ES 语言和 js 语言，使两者可以相互通信
3. 找一支触控笔 - 通过 canvas 获取的 webgl 类型的上下文对象，可以向手绘板传递绘图命令，并接收手绘板的状态信息
4. 开始画画 - 通过 webgl 类型的上下文对象，用 js 画画

```html
<canvas id="canvas"></canvas>
<!-- 顶点着色器 -->
<script id="vertexShader" type="x-shader/x-vertex">
  void main(){
    //点位
    gl_Position=vec4(1,1,1,2);
    //尺寸
    gl_PointSize=50.0;
  }
</script>
<!-- 片元着色器 -->
<script id="fragmentShader" type="x-shader/x-fragment">
  void main(){
    // 片元的颜色
    gl_FragColor=vec4(1,1,0,1);
  }
</script>
<script type="module">
  // canvas 画布
  const canvas = document.querySelector("#canvas");
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;

  // 获取着色器文本
  const vsSource = document.querySelector("#vertexShader").innerText;
  const fsSource = document.querySelector("#fragmentShader").innerText;

  //三维画笔
  const gl = canvas.getContext("webgl");

  //初始化着色器
  //功能：解析着色器文本，整合到程序对象里，关联webgl上下文对象，实现两种语言的相互通信
  initShaders(gl, vsSource, fsSource);

  //声明颜色 rgba
  gl.clearColor(0, 0, 0, 1);
  //刷底色
  gl.clear(gl.COLOR_BUFFER_BIT);
  //绘制顶点
  gl.drawArrays(gl.POINTS, 0, 1);

  function initShaders(gl, vsSource, fsSource) {
    //创建程序对象
    const program = gl.createProgram();
    //建立着色对象
    const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
    const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);
    //把顶点着色对象装进程序对象中
    gl.attachShader(program, vertexShader);
    //把片元着色对象装进程序对象中
    gl.attachShader(program, fragmentShader);
    //连接webgl上下文对象和程序对象
    gl.linkProgram(program);
    //启动程序对象
    gl.useProgram(program);
    //将程序对象挂到上下文对象上
    gl.program = program;
    return true;
  }

  function loadShader(gl, type, source) {
    //根据着色类型，建立着色器对象
    const shader = gl.createShader(type);
    //将着色器源文件传入着色器对象中
    gl.shaderSource(shader, source);
    //编译着色器对象
    gl.compileShader(shader);
    //返回着色器对象
    return shader;
  }
</script>
```

#### 4) webgl 着色器

webgl 绘图需要两种着色器：

- 顶点着色器（Vertex shader）：描述顶点的特征，如位置、颜色等
- 片元着色器（Fragment shader）：进行逐片元处理，如光照
  > 两点决定一条直线，顶点着色器里的顶点就是决定这一条直线的两个点，片元着色器里的片元就是把直线画到画布上后，这两个点之间构成直线的每个像素

## 三、js 与着色器间的数据传输

### 1. js 控制顶点位置

> attribute 变量是只有顶点着色器才能使用它的  
> js 可以通过 attribute 变量向顶点着色器传递与顶点相关的数据

```html
<canvas id="canvas"></canvas>
<!-- 顶点着色器 -->
<script id="vertexShader" type="x-shader/x-vertex">
  attribute vec4 a_Position;
  void main(){
      //点位
      gl_Position = a_Position;
      //尺寸
      gl_PointSize = 50.0;
  }
</script>
<!-- 片元着色器 -->
<script id="fragmentShader" type="x-shader/x-fragment">
  void main(){
      //片元的颜色
      gl_FragColor = vec4(1,1,0,1);
  }
</script>
<script type="module">
  import { initShaders } from "../jsm/Utils.js";

  const canvas = document.querySelector("#canvas");
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;

  // 获取着色器文本
  const vsSource = document.querySelector("#vertexShader").innerText;
  const fsSource = document.querySelector("#fragmentShader").innerText;

  //三维画笔
  const gl = canvas.getContext("webgl");

  //初始化着色器
  initShaders(gl, vsSource, fsSource);

  //声明颜色 rgba
  gl.clearColor(0, 0, 0, 1);
  //刷底色
  gl.clear(gl.COLOR_BUFFER_BIT);

  /*
   * 获取attribute 变量
   * gl.getAttribLocation() 是获取着色器中attribute 变量的方法
   * gl.program 是初始化着色器时，在上下文对象上挂载的程序对象
   * 'a_Position' 是着色器暴露出的变量名
   */
  const a_Position = gl.getAttribLocation(gl.program, "a_Position");

  //修改attribute 变量
  gl.vertexAttrib3f(a_Position, 0, 0.5, 0);
  // gl.vertexAttrib2f(a_Position, 0.5, 0.5);
  // gl.vertexAttrib1f(a_Position, 0.1);

  //绘制顶点
  gl.drawArrays(gl.POINTS, 0, 1);
</script>
```

### 2. 鼠标控制点位

1. canvas 坐标系转 webgl 坐标系

```js
canvas.addEventListener("click", function(event) {
  const { clientX, clientY } = event;
  const { left, top, width, height } = canvas.getBoundingClientRect();
  const [cssX, cssY] = [clientX - left, clientY - top];
  //解决坐标原点位置的差异
  const [halfWidth, halfHeight] = [width / 2, height / 2];
  const [xBaseCenter, yBaseCenter] = [cssX - halfWidth, cssY - halfHeight];
  // 解决y 方向的差异
  const yBaseCenterTop = -yBaseCenter;
  //解决坐标基底的差异
  const [x, y] = [xBaseCenter / halfWidth, yBaseCenterTop / halfHeight];
});
```

2. 修改 attribute 变量
   1. 获取 attribute 变量
   2. 在获取鼠标在 webgl 画布中的位置的时候，修改 attribute 变量
   3. 清理画布
   4. 绘图

```js
gl.vertexAttrib2f(a_Position, x, y);
gl.clear(gl.COLOR_BUFFER_BIT);
gl.drawArrays(gl.POINTS, 0, 1);
```

3. webgl 的同步绘图原理
   > gl.drawArrays(gl.POINTS, 0, 1) 方法和 canvas 2d 里的 ctx.draw() 方法是不一样的，ctx.draw() 真的像画画一样，一层一层的覆盖图像  
   > gl.drawArrays() 方法只会同步绘图，走完了 js 主线程后，再次绘图时，就会从头再来。也就说，异步执行的 drawArrays() 方法会把画布上的图像都刷掉：  
   > 原理 => webgl 绘图的时候，是先在颜色缓冲区中画出来，颜色缓冲区中存储的图像，只在当前线程有效。比如我们先在 js 主线程中绘图，主线程结束后，会再去执行信息队列里的异步线程。在执行异步线程时，颜色缓冲区就会被 webgl 系统重置

**鼠标绘制多个点**

```js
const a_Position = gl.getAttribLocation(gl.program, "a_Position");
gl.clearColor(0.0, 0.0, 0.0, 1.0);
gl.clear(gl.COLOR_BUFFER_BIT);

const g_points = [];
canvas.addEventListener("click", function(event) {
  const { clientX, clientY } = event;
  const { left, top, width, height } = canvas.getBoundingClientRect();
  const [cssX, cssY] = [clientX - left, clientY - top];
  const [halfWidth, halfHeight] = [width / 2, height / 2];
  const [xBaseCenter, yBaseCenter] = [cssX - halfWidth, cssY - halfHeight];
  const yBaseCenterTop = -yBaseCenter;
  const [x, y] = [xBaseCenter / halfWidth, yBaseCenterTop / halfHeight];

  g_points.push({ x, y });
  gl.clear(gl.COLOR_BUFFER_BIT);
  g_points.forEach(({ x, y }) => {
    gl.vertexAttrib2f(a_Position, x, y);
    gl.drawArrays(gl.POINTS, 0, 1);
  });
});
```

### 3. js 控制顶点尺寸

```html
<canvas id="canvas"></canvas>
<!-- 顶点着色器 -->
<script id="vertexShader" type="x-shader/x-vertex">
  attribute vec4 a_Position;
  attribute float a_PointSize;
  void main(){
      //点位
      gl_Position=a_Position;
      //尺寸
      gl_PointSize=a_PointSize;
  }
</script>
<!-- 片元着色器 -->
<script id="fragmentShader" type="x-shader/x-fragment">
  void main(){
      gl_FragColor=vec4(1,1,0,1);
  }
</script>
<script type="module">
  import { initShaders } from "../jsm/Utils.js";

  const canvas = document.querySelector("#canvas");
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;

  // 获取着色器文本
  const vsSource = document.querySelector("#vertexShader").innerText;
  const fsSource = document.querySelector("#fragmentShader").innerText;

  //三维画笔
  const gl = canvas.getContext("webgl");

  //初始化着色器
  initShaders(gl, vsSource, fsSource);

  //获取attribute 变量
  const a_Position = gl.getAttribLocation(gl.program, "a_Position");
  const a_PointSize = gl.getAttribLocation(gl.program, "a_PointSize");

  //修改attribute 变量
  gl.vertexAttrib1f(a_Position, 0.1);
  gl.vertexAttrib1f(a_PointSize, 50);

  //声明颜色 rgba
  gl.clearColor(0, 0, 0, 1);

  //刷底色
  gl.clear(gl.COLOR_BUFFER_BIT);

  //绘制顶点
  gl.drawArrays(gl.POINTS, 0, 1);
</script>
```

**鼠标随机改变顶点大小**

```html
<canvas id="canvas"></canvas>
<!-- 顶点着色器 -->
<script id="vertexShader" type="x-shader/x-vertex">
  attribute vec4 a_Position;
  attribute float a_PointSize;
  void main(){
      //点位
      gl_Position=a_Position;
      //尺寸
      gl_PointSize=a_PointSize;
  }
</script>
<!-- 片元着色器 -->
<script id="fragmentShader" type="x-shader/x-fragment">
  void main(){
      gl_FragColor=vec4(1,1,0,1);
  }
</script>
<script type="module">
  import { initShaders } from "../jsm/Utils.js";

  const canvas = document.querySelector("#canvas");
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;

  // 获取着色器文本
  const vsSource = document.querySelector("#vertexShader").innerText;
  const fsSource = document.querySelector("#fragmentShader").innerText;

  //三维画笔
  const gl = canvas.getContext("webgl");

  //初始化着色器
  initShaders(gl, vsSource, fsSource);

  // 获取attribute 变量
  const a_Position = gl.getAttribLocation(gl.program, "a_Position");
  const a_PointSize = gl.getAttribLocation(gl.program, "a_PointSize");

  // 顶点
  const a_points = [{ x: 0, y: 0, size: 10 }];

  //声明颜色 rgba
  gl.clearColor(0, 0, 0, 1);

  //刷底色
  gl.clear(gl.COLOR_BUFFER_BIT);

  render();

  // 鼠标点击事件
  canvas.addEventListener("click", ({ clientX, clientY }) => {
    console.log(clientX, clientY);
    const { left, top, width, height } = canvas.getBoundingClientRect();
    const [cssX, cssY] = [clientX - left, clientY - top];
    //解决坐标原点位置的差异
    const [halfWidth, halfHeight] = [width / 2, height / 2];
    const [xBaseCenter, yBaseCenter] = [cssX - halfWidth, cssY - halfHeight];
    // 解决y 方向的差异
    const yBaseCenterTop = -yBaseCenter;
    //解决坐标基底的差异
    const [x, y] = [xBaseCenter / halfWidth, yBaseCenterTop / halfHeight];

    const size = Math.random() * 50 + 10;
    a_points.push({ x, y, size });
    render();
  });

  // 渲染方法
  function render() {
    gl.clear(gl.COLOR_BUFFER_BIT);
    a_points.forEach(({ x, y, size }) => {
      gl.vertexAttrib2f(a_Position, x, y);
      gl.vertexAttrib1f(a_PointSize, size);
      gl.drawArrays(gl.POINTS, 0, 1);
    });
  }
</script>
```

### 4. js 控制顶点的颜色

**限定颜色变量的限定符叫 uniform**

```html
<canvas id="canvas"></canvas>
<!-- 顶点着色器 -->
<script id="vertexShader" type="x-shader/x-vertex">
  attribute vec4 a_Position;
  void main(){
      //点位
      gl_Position=a_Position;
      //尺寸
      gl_PointSize=50.0;
  }
</script>
<!-- 片元着色器 -->
<script id="fragmentShader" type="x-shader/x-fragment">
  precision mediump float;
  uniform vec4 u_FragColor;
  void main(){
      gl_FragColor=u_FragColor;
  }
</script>
<script type="module">
  import { initShaders } from "../jsm/Utils.js";

  const canvas = document.querySelector("#canvas");
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;

  // 获取着色器文本
  const vsSource = document.querySelector("#vertexShader").innerText;
  const fsSource = document.querySelector("#fragmentShader").innerText;

  //三维画笔
  const gl = canvas.getContext("webgl");

  //初始化着色器
  initShaders(gl, vsSource, fsSource);

  //声明颜色 rgba
  gl.clearColor(0, 0, 0, 1);
  //刷底色
  gl.clear(gl.COLOR_BUFFER_BIT);

  //获取attribute 变量
  const a_Position = gl.getAttribLocation(gl.program, "a_Position");

  //获取uniform 变量
  const u_FragColor = gl.getUniformLocation(gl.program, "u_FragColor");

  //修改attribute 变量
  gl.vertexAttrib1f(a_Position, 0.1);

  //修改uniform 变量
  gl.uniform4f(u_FragColor, 1, 0, 1, 1);

  //绘制顶点
  gl.drawArrays(gl.POINTS, 0, 1);
</script>
```

**鼠标随机改变顶点颜色**

```html
<canvas id="canvas"></canvas>
<!-- 顶点着色器 -->
<script id="vertexShader" type="x-shader/x-vertex">
  attribute vec4 a_Position;
  attribute float a_PointSize;
  void main(){
      //点位
      gl_Position=a_Position;
      //尺寸
      gl_PointSize=a_PointSize;
  }
</script>
<!-- 片元着色器 -->
<script id="fragmentShader" type="x-shader/x-fragment">
  precision mediump float;
  uniform vec4 u_FragColor;
  void main(){
      gl_FragColor=u_FragColor;
  }
</script>
<script type="module">
  import { initShaders } from "../jsm/Utils.js";

  const canvas = document.querySelector("#canvas");
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;

  // 获取着色器文本
  const vsSource = document.querySelector("#vertexShader").innerText;
  const fsSource = document.querySelector("#fragmentShader").innerText;

  //三维画笔
  const gl = canvas.getContext("webgl");

  //初始化着色器
  initShaders(gl, vsSource, fsSource);

  //获取attribute 和 uniform 变量
  const a_Position = gl.getAttribLocation(gl.program, "a_Position");
  const a_PointSize = gl.getAttribLocation(gl.program, "a_PointSize");
  const u_FragColor = gl.getUniformLocation(gl.program, "u_FragColor");

  const a_points = [
    { x: 0, y: 0, size: 10, color: { r: 1, g: 0, b: 0, a: 1 } },
  ];

  //声明颜色 rgba
  gl.clearColor(0, 0, 0, 1);

  //刷底色
  gl.clear(gl.COLOR_BUFFER_BIT);

  render();

  // 鼠标点击事件
  canvas.addEventListener("click", ({ clientX, clientY }) => {
    console.log(clientX, clientY);
    const { left, top, width, height } = canvas.getBoundingClientRect();
    const [cssX, cssY] = [clientX - left, clientY - top];
    //解决坐标原点位置的差异
    const [halfWidth, halfHeight] = [width / 2, height / 2];
    const [xBaseCenter, yBaseCenter] = [cssX - halfWidth, cssY - halfHeight];
    // 解决y 方向的差异
    const yBaseCenterTop = -yBaseCenter;
    //解决坐标基底的差异
    const [x, y] = [xBaseCenter / halfWidth, yBaseCenterTop / halfHeight];

    const size = Math.random() * 50 + 10;
    const n = Math.random();
    const color = { r: n, g: n, b: 1, a: 1 };
    a_points.push({ x, y, size, color });
    render();
  });

  // 渲染方法
  function render() {
    gl.clear(gl.COLOR_BUFFER_BIT);
    a_points.forEach(({ x, y, size, color: { r, g, b, a } }) => {
      gl.vertexAttrib2f(a_Position, x, y);
      gl.vertexAttrib1f(a_PointSize, size);
      // gl.uniform4f(u_FragColor, r, g, b, a);
      const arr = new Float32Array([r, g, b, a]);
      // Float32Array 是一种32 位的浮点型数组，它在浏览器中的运行效率要比普通的Array 高很多
      gl.uniform4fv(u_FragColor, arr);
      gl.drawArrays(gl.POINTS, 0, 1);
    });
  }
</script>
```

## 四、绘制图形

**三角形是一个最简单、最稳定的面，webgl 中的三维模型都是由三角面组成的**

### 1.webgl 的绘图方式

- 绘制多点  
  ![](../img/2021/1220/4.png)

- 如果是线，就连点成线  
  ![](../img/2021/1220/5.png)

- 如果是面，那就在图形内部，逐片元填色  
  ![](../img/2021/1220/6.png)

### 2. 绘制多点

> 在 js 中建立顶点数据，着色器肯定是拿不到的，这是语言不通导致的，为了解决这个问题，webgl 系统就建立了一个能翻译双方语言的缓冲区  
> js 可以用特定的方法把数据存在这个缓冲区中，着色器可以从缓冲区中拿到相应的数据

1. 建立顶点数据，两个浮点数构成一个顶点，分别代表 x、y 值

```js
const vertices = new Float32Array([
  //x    y
  0.0,
  0.1, //顶点
  -0.1,
  -0.1, //顶点
  0.1,
  -0.1, //顶点
]);
// 这些顶点数据是存储在js 缓存里的，着色器拿不到，所以需要建立一个着色器和js 都能进入的公共区
```

2. 建立缓冲对象

```js
const vertexBuffer = gl.createBuffer();
// 上面的这个缓冲区是独立存在的，它只是一个空着的仓库，和谁都没有关系。接下就让其和着色器建立连接
```

3. 绑定缓冲对象

```js
gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);

// gl.bindBuffer(target,buffer)   绑定缓冲区
// - target  要把缓冲区放在webgl 系统中的什么位置
// - buffer 缓冲区

// 着色器对象在执行initShaders() 初始化方法的时候，已经被写入webgl 上下文对象gl 中了。
// 当缓冲区和着色器建立了绑定关系，我们就可以往这块空间写入数据了
```

4. 往缓冲区对象中写入数据

```js
gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

// bufferData(target, data, usage) 将数据写入缓冲区
// - target 要把缓冲区放在webgl 系统中的什么位置
// - data  数据
// - usage 向缓冲区写入数据的方式，咱们在这里先知道 gl.STATIC_DRAW 方式即可，
//它是向缓冲区中一次性写入数据，着色器会绘制多次。

// 现在着色器虽然绑定了缓冲区，可以访问里面的数据了，但是我们还得让着色器知道这个仓库是给哪个变量的，
//比如咱们这里用于控制点位的attribute 变量。这样做是为了提高绘图效率。
```

5. 将缓冲区对象分配给 attribute 变量

```js
const a_Position = gl.getAttribLocation(gl.program, "a_Position");
gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 0, 0);

// gl.vertexAttribPointer(local,size,type,normalized,stride,offset)   将缓冲区对象分配给attribute 变量

// - local  attribute变量
// - size 顶点分量的个数，比如我们的vertices 数组中，两个数据表示一个顶点，那咱们就写2
// - type 数据类型，比如 gl.FLOAT 浮点型
// - normalized 是否将顶点数据归一
// - stride 相邻两个顶点间的字节数，我的例子里写的是0，那就是顶点之间是紧挨着的
// - offset 从缓冲区的什么位置开始存储变量，我的例子里写的是0，那就是从头开始存储变量

// 到了这里，着色就知道缓冲区的数据是给谁的了。因为缓冲区里的顶点数据是数组，里面有多个顶点。
//所以得开启一个让着色器批量处理顶点数据的属性。默认着色器只会一个一个的接收顶点数据，然后一个一个的绘制顶点。
```

6. 开启顶点数据的批处理功能

```js
gl.enableVertexAttribArray(a_Position);

// - location attribute变量
```

7. 绘图

```js
gl.clearColor(0.0, 0.0, 0.0, 1.0);
gl.clear(gl.COLOR_BUFFER_BIT);
gl.drawArrays(gl.POINTS, 0, 3);

// drawArrays(mode,first,count)

// - mode 绘图模式，比如 gl.POINTS 画点
// - first 从哪个顶点开始绘制
// - count 要画多少个顶点
```

**整体代码**

```html
<canvas id="canvas"></canvas>
<!-- 顶点着色器 -->
<script id="vertexShader" type="x-shader/x-vertex">
  attribute vec4 a_Position;
  void main(){
      //点位
      gl_Position=a_Position;
      //尺寸
      gl_PointSize=50.0;
  }
</script>
<!-- 片元着色器 -->
<script id="fragmentShader" type="x-shader/x-fragment">
  void main(){
      gl_FragColor=vec4(1,1,0,1);
  }
</script>
<script type="module">
  import { initShaders } from "../jsm/Utils.js";

  const canvas = document.querySelector("#canvas");
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;

  // 获取着色器文本
  const vsSource = document.querySelector("#vertexShader").innerText;
  const fsSource = document.querySelector("#fragmentShader").innerText;

  //三维画笔
  const gl = canvas.getContext("webgl");

  //初始化着色器
  initShaders(gl, vsSource, fsSource);

  //如何向attribute 变量中写入多点，并绘制多点
  //顶点数据
  const vertices = new Float32Array([0, 0.2, -0.2, -0.1, 0.2, -0.1, 0.4, 0.2]);
  //缓冲对象
  const vertexBuffer = gl.createBuffer();
  //绑定缓冲对象
  gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
  //写入数据
  gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
  //获取attribute 变量
  const a_Position = gl.getAttribLocation(gl.program, "a_Position");
  //修改attribute 变量
  gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 0, 0);
  //赋能-批处理
  gl.enableVertexAttribArray(a_Position);

  //声明颜色 rgba
  gl.clearColor(0, 0, 0, 1);

  //刷底色
  gl.clear(gl.COLOR_BUFFER_BIT);

  //绘制顶点
  gl.drawArrays(gl.POINTS, 0, 4);
</script>
```

### 3. 绘制图形

1. 绘制三角面

- 顶点着色器中的 gl_PointSize = 20.0 不要，因为这个属性是控制顶点大小的，咱们已经不需要显示顶点了。

```js
<script id="vertexShader" type="x-shader/x-vertex">
    attribute vec4 a_Position;
    void main(){
        gl_Position = a_Position;
        //gl_PointSize = 20.0;
    }
</script>
```

- 在 js 中修改绘图方式

```js
// gl.drawArrays(gl.POINTS, 0, 3);
gl.drawArrays(gl.TRIANGLES, 0, 3);
```

**gl.TRIANGLES 就是绘制三角面**

![](../img/2021/1220/7.png)

2. 基本图形

gl.drawArrays(mode,first,count) 方法可以绘制一下图形：

- POINTS 可视的点
- LINES 单独线段
- LINE_STRIP 线条
- LINE_LOOP 闭合线条
- TRIANGLES 单独三角形
- TRIANGLE_STRIP 三角带
- TRIANGLE_FAN 三角扇

  **2.1 点的绘制**  
   POINTS 可视的点

  ![](../img/2021/1220/8.png)

  上面六个点的绘制顺序是：v0, v1, v2, v3, v4, v5

  **2.2 线的绘制**

  1. LINES 单独线段

  ![](../img/2021/1220/9.png)

  上面三条有向线段的绘制顺序是：  
  ​ v0>v1  
  ​ v2>v3  
  ​ v4>v5

  2. LINE_STRIP 线条

  ![](../img/2021/1220/10.png)

  上面线条的绘制顺序是：v0>v1>v2>v3>v4>v5

  3. LINE_LOOP 闭合线条

  ![](../img/2021/1220/11.png)

  上面线条的绘制顺序是：v0>v1>v2>v3>v4>v5>v0

  **2.3 面的绘制**

  对于面的绘制，我们首先要知道一个原理：

  - 面有正反两面。
  - 面向我们的面，如果是正面，那它必然是逆时针绘制的；
  - 面向我们的面，如果是反面，那它必然是顺时针绘制的；

  接下来，看下面的三种绘制方式：

  1. TRIANGLES 单独三角形

  ![](../img/2021/1220/12.png)

  上面两个面的绘制顺序是：​  
  ​ v0>v1>v2  
  ​ v3>v4>v5

  2. TRIANGLE_STRIP 三角带

  ![](../img/2021/1220/13.png)

  上面四个面的绘制顺序是：  
  v0>v1>v2  
  以上一个三角形的第二条边+下一个点为基础，以和第二条边相反的方向绘制三角形  
  v2>v1>v3  
  以上一个三角形的第三条边+下一个点为基础，以和第三条边相反的方向绘制三角形  
  v2>v3>v4  
  以上一个三角形的第二条边+下一个点为基础，以和第二条边相反的方向绘制三角形  
  v4>v3>v5

  规律：  
  第一个三角形：v0>v1>v2  
  第偶数个三角形：以上一个三角形的第二条边+下一个点为基础，以和第二条边相反的方向绘制三角形  
  第奇数个三角形：以上一个三角形的第三条边+下一个点为基础，以和第三条边相反的方向绘制三角形

  3. TRIANGLE_FAN 三角扇

  ![](../img/2021/1220/14.png)

  上面四个面的绘制顺序是：  
  ​ v0>v1>v2  
  以上一个三角形的第三条边+下一个点为基础，按照和第三条边相反的顺序，绘制三角形  
  ​ v0>v2>v3  
  以上一个三角形的第三条边+下一个点为基础，按照和第三条边相反的顺序，绘制三角形  
  ​ v0>v3>v4  
  以上一个三角形的第三条边+下一个点为基础，按照和第三条边相反的顺序，绘制三角形  
  ​ v0>v4>v5

### 4. 绘制矩形

首先，webgl 可以绘制的面只有三角面，所以要绘制矩形面的话，只能用两个三角形去拼。

1. TRIANGLE_STRIP 三角带拼矩形

![](../img/2021/1220/15.png)

上面的两个三角形分别是：  
v0>v1>v2  
v2>v1>v3

```js
// 1.建立顶点数据(下面两个浮点代表一个顶点，依次是v0、v1、v2、v3，如上图所示)
const vertices = new Float32Array([-0.2, 0.2, -0.2, -0.2, 0.2, 0.2, 0.2, -0.2]);

// 2.绘图
gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
```

效果如下：

![](../img/2021/1220/16.png)

### 5. 异步绘制多点

> 当缓冲区被绑定在了 webgl 上下文对象上后，我们在异步方法里直接对其进行修改即可，顶点着色器在绘图的时候会自动从其中调用数据。  
> WebGLBuffer 缓冲区中的数据在异步方法里不会被重新置空。

```html
<canvas id="canvas"></canvas>
<!-- 顶点着色器 -->
<script id="vertexShader" type="x-shader/x-vertex">
  attribute vec4 a_Position;
  void main(){
      gl_Position=a_Position;
      gl_PointSize=20.0;
  }
</script>
<!-- 片元着色器 -->
<script id="fragmentShader" type="x-shader/x-fragment">
  void main(){
      gl_FragColor=vec4(1,1,0,1);
  }
</script>
<script type="module">
  import { initShaders } from "../jsm/Utils.js";

  const canvas = document.querySelector("#canvas");
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;

  // 获取着色器文本
  const vsSource = document.querySelector("#vertexShader").innerText;
  const fsSource = document.querySelector("#fragmentShader").innerText;

  //三维画笔
  const gl = canvas.getContext("webgl");

  //初始化着色器
  initShaders(gl, vsSource, fsSource);

  //顶点数据
  let vertices = [0, 0.2];
  //缓冲对象
  const vertexBuffer = gl.createBuffer();
  //绑定缓冲对象
  gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
  //写入数据
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
  //获取attribute 变量
  const a_Position = gl.getAttribLocation(gl.program, "a_Position");
  //修改attribute 变量
  gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 0, 0);
  //赋能-批处理
  gl.enableVertexAttribArray(a_Position);

  //声明颜色 rgba
  gl.clearColor(0, 0, 0, 1);
  //刷底色
  gl.clear(gl.COLOR_BUFFER_BIT);
  //绘制顶点
  gl.drawArrays(gl.POINTS, 0, 1);

  setTimeout(() => {
    vertices.push(-0.2, -0.1);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.drawArrays(gl.POINTS, 0, 2);
  }, 1000);

  setTimeout(() => {
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.drawArrays(gl.POINTS, 0, 2);
    gl.drawArrays(gl.LINE_STRIP, 0, 2);
  }, 2000);
</script>
```

### 6.图形转面

**“砍角”，其原理就是从起点将多边形中符合特定条件的角逐个砍掉，然后保存到一个集合里，直到把多边形砍得只剩下一个三角形为止。这时候集合里的所有三角形就是想要的独立三角形**

## 五、矩阵变换

变换有三种状态：平移、旋转、缩放。

当变换一个图形时，实际上就是在移动这个图形的所有顶点。

### 1.平移

对图形的平移就是对图形所有顶点的平移

![](../img/2021/1220/17.png)

在实际代码中，要有一个向量的概念，比如 (x,y,z) ，我们既可以说它是一个顶点位置，也可以说它是一个向量，顶点的位移其实就是向量的加法。

GLSL ES 语言里的向量运算

```js
attribute vec4 a_Position;
vec4 translation=vec4(0,0.2,0,0);
void main(){
    gl_Position = a_Position+translation;
}
```

- a_Position 是原始点位，属于 attribute 变量
- translation 是顶点着色器里的私有变量，没有向外部暴露，属于 4 维向量
- a_Position+translation 便是着色器内的向量加法，这里是对原始点位进行位移

### 2.旋转

物体的旋转方向是有正负之分的，在 webgl 中，除裁剪空间之外的大部分功能都使用了右手坐标系。

![](../img/2021/1220/18.png)

- 当物体绕 z 轴，从 x 轴正半轴向 y 轴正半轴逆时针旋转时，是正向旋转，反之为负。
- 当物体绕 x 轴，从 y 轴正半轴向 z 轴正半轴逆时针旋转时，是正向旋转，反之为负。
- 当物体绕 y 轴，从 z 轴正半轴向 x 轴正半轴逆时针旋转时，是正向旋转，反之为负。

旋转公式:

由一个让顶点围绕 z 轴旋转的例子引出

![](../img/2021/1220/19.png)

已知：

- 点 A 的位置是(ax,ay,az)
- 点 A 要围绕 z 轴旋转 β 度，转到点 B 的位置

求：点 A 旋转后的 bx、by 位置

因为 ∠β 是已知的，∠α 可以通过点 A 得出:

```js
∠xOB=α+β
```

三角函数就可以推出 bx、by

设 ∠xOB=θ，则：

```js
bx=cosθ*|OA|
by=sinθ*|OA|
```

|OA|是点 O 到点 A 的距离，可以直接用点 A 求出:

```js
|OA|=Math.sqrt(ax*ax+ay*ay)
```

只需要知道 cosθ 和 sinθ 的值即可，因为：θ=α+β  
所以可以利用和角公式求 cosθ 和 sinθ 的值：

```js
cosθ = cos(α + β);
cosθ = cosα * cosβ - sinα * sinβ;

sinθ = sin(α + β);
sinθ = cosβ * sinα + sinβ * cosα;
```

所以：

```js
bx=cosθ*|OA|
bx=(cosα*cosβ-sinα*sinβ)*|OA|
bx=cosα*cosβ*|OA|-sinα*sinβ*|OA|

by=sinθ*|OA|
by=(cosβ*sinα+sinβ*cosα)*|OA|
by=cosβ*sinα*|OA|+sinβ*cosα*|OA|
```

因为：

```js
cosα*|OA|=ax
sinα*|OA|=ay
```

简化得到 bx、by 的公式：

```js
bx = ax * cosβ - ay * sinβ;
by = ay * cosβ + ax * sinβ;
```

在着色器中旋转

```js
<script id="vertexShader" type="x-shader/x-vertex">
    attribute vec4 a_Position;
    float angle=radians(80.0);
    float sinB=sin(angle);
    float cosB=cos(angle);
    void main(){
        gl_Position.x=a_Position.x*cosB-a_Position.y*sinB;
        gl_Position.y=a_Position.y*cosB+a_Position.x*sinB;
        gl_Position.z=a_Position.z;
        gl_Position.w=1.0;
    }
</script>
```

- radians(float degree) 将角度转弧度
- sin(float angle) 正弦
- cos(float angle) 余弦

### 3.缩放

缩放可以理解为对向量长度的改变，或者对向量坐标分量的同步缩放

![](../img/2021/1220/20.png)

已知：

- 点 A 的位置是(ax,ay,az)
- 点 A 基于原点內缩了一半

求：点 A 內缩了一半后的 bx、by、bz 位置

解：

```js
bx = ax * 0.5;
by = ay * 0.5;
bz = az * 0.5;
```

在着色器中缩放

对 gl_Position 的 x、y、z 依次缩放：

```js
<script id="vertexShader" type="x-shader/x-vertex">
attribute vec4 a_Position;
float scale=1.2;
void main(){
	gl_Position.x= a_Position.x*scale;
	gl_Position.y= a_Position.y*scale;
	gl_Position.z= a_Position.z*scale;
	gl_Position.w=1.0;
}
</script>
```

a_Position 中抽离出由 x、y、z 组成的三维向量，对其进行一次性缩放：

```js
<script id="vertexShader" type="x-shader/x-vertex">
attribute vec4 a_Position;
float scale=1.2;
void main(){
	gl_Position=vec4(vec3(a_Position)*scale,1.0);
}
</script>
```

### 4.矩阵

矩阵（Matrix）是一个按照矩形纵横排列的复数集合

在矩阵中的每一行，或者每一列数字构成的集合，可以视之为向量

1. 向量

向量，又叫矢量，指具有大小（magnitude）和方向的量

webgl 里的向量有 1 维向量、2 维向量、3 维向量和 4 维向量：

- 维向量中有 1 个数字，对应的是单轴坐标系里的点位。
- 2 维向量中有 2 个数字，对应的是 2 维坐标系里的点位。
- 3 维向量中有 3 个数字，对应的是 3 维坐标系里的点位。
- 4 维向量中有 4 个数字，对应的是 3 维坐标系里的点位，外加一个附加数据，至于这个数据是什么，要看项目需求。

2. 矩阵和向量的乘法

矩阵和向量的乘法：

![](../img/2021/1220/21.png)

用专业术语来说：

- 横着的两组遵循的规则是行主序，即将矩阵中的一行数据视之为一个向量。
- 竖着的两组遵循的规则是列主序，即将矩阵中的一列数据视之为一个向量。

至于是使用行主序，还是列主序，这就得看规则的定制者了。

在 webgl 里，矩阵元素的排列规则是列主序。

数学中常用的写法是行主序

可以用矩阵乘以向量的方式让点 p 旋转 β 度：

![](../img/2021/1220/22.png)

3. 在着色器中写矩阵

```js
<script id="vertexShader" type="x-shader/x-vertex">
    attribute vec4 a_Position;
    float angle=radians(40.0);
    float sinB=sin(angle);
    float cosB=cos(angle);
    mat2 m2=mat2(
      cosB, sinB,
      -sinB,cosB
    );
    void main(){
      gl_Position = vec4(
        m2*vec2(a_Position),
        a_Position.z,a_Position.w
      );
    }
</script>
```

4. 四维矩阵

```js
<script id="vertexShader" type="x-shader/x-vertex">
    attribute vec4 a_Position;
    float angle=radians(10.0);
    float cosB=cos(angle);
    float sinB=sin(angle);
    //列主序
    mat4 m4=mat4(
      cosB, sinB,0.0,0.0,
      -sinB,cosB,0.0,0.0,
      0.0,  0.0, 1.0,0.0,
      0.0,  0.0, 0.0,1.0
    );
    void main(){
      gl_Position = m4*a_Position;
    }
</script>
```

5. 矩阵平移

让顶点的 x 移动 0.1，y 移动 0.2，z 移动 0.3：

```js
<script id="vertexShader" type="x-shader/x-vertex">
    attribute vec4 a_Position;
    //列主序
    mat4 m4=mat4(
      1.0, 0.0, 0.0,0.0,
      0.0, 1.0, 0.0,0.0,
      0.0, 0.0, 1.0,0.0,
      0.1, 0.2, 0.3,1.0
    );
    void main(){
      gl_Position = m4*a_Position;
    }
</script>
```

6. 矩阵缩放

顶点在 x 轴向缩放 2，y 轴向缩放 3，轴向缩放 4：

```js
<script id="vertexShader" type="x-shader/x-vertex">
    attribute vec4 a_Position;
    //列主序
    mat4 m4=mat4(
      2.0, 0.0, 0.0,0.0,
      0.0, 3.0, 0.0,0.0,
      0.0, 0.0, 4.0,0.0,
      0.0, 0.0, 0.0,1.0
    );
    void main(){
      gl_Position = m4*a_Position;
    }
</script>
```

7. 矩阵库

three.js 的 Matrix3 和 Matrix4 对象：

```js
// 1.引入Matrix4对象
import { Matrix4 } from "https://unpkg.com/three/build/three.module.js";

// 2.实例化矩阵对象，在其中写入旋转信息
const matrix = new Matrix4();
matrix.makeRotationZ(Math.PI / 6);

// 3.基于matrix 对象的elements 属性，修改uniform 变量
const u_Matrix = gl.getUniformLocation(gl.program, "u_Matrix");
gl.uniformMatrix4fv(u_Matrix, false, matrix.elements);
```

## 六、 矩阵复合变换

### 1.矩阵相乘

矩阵相乘可以实现复合变换，就比如先位移再旋转、先旋转在位移，或着连续位移。

矩阵乘以矩阵的结果还是矩阵，我们可以通过矩阵库验证一下矩阵相乘的规律。

1. 使用 three.js 的 Matrix4 对象建立矩阵

```json
const a=new Matrix4().set(
    0, 1, 2, 3,
    4, 5, 6, 7,
    8, 9, 10,11,
    12,13,14,15
)
const b=new Matrix4().set(
    0,  10, 20, 30,
    40, 50, 60, 70,
    80, 90, 100,110,
    120,130,140,150
)
```

注：set()方法里输入的矩阵是行主序的，但 elements 输出的矩阵是列主序的。

```json
const ca=a.elements
console.log(ca);
[
    0, 4, 8,  12,
    1, 5, 9,  13,
    2, 6, 10, 14,
    3, 7, 11, 15
]

const cb=b.elements
console.log(cb);
[
    0,  40, 80, 120,
    10, 50, 90, 130,
    20, 60, 100, 140,
    30, 70, 110, 150

```

2. 让矩阵 a 乘以矩阵 b

```json
const c=a.multiply(b)
console.log(c.elements);
[
    560, 1520, 2480, 3440,
    620, 1740, 2860, 3980,
    680, 1960, 3240, 4520,
    740, 2180, 3620, 5060
]
```

分析一下结果

```js
560=0*0 +1*40+2*80 +3*120
620=0*10+1*50+2*90 +3*130
680=0*20+1*60+2*100+3*140
740=0*30+1*70+2*110+3*150

1520=4*0 +5*40+6*80 +7*120
1740=4*10+5*50+6*90 +7*130
……
```

总结出矩阵 a 乘以矩阵 b 规律:

以列主序的 ca、cb 为例：  
先遍历 ca 的每一列，再遍历 cb 的每一行，将 ca 的每一列乘以 cb 的每一行，按照列主序排列后得到的结果。

以行主序的 ca、cb 为例：  
先遍历 ca 的每一行，再遍历 cb 的每一列，将 ca 的每一行乘以 cb 的每一列，按照行主序排列后得到的结果。

验证一下后者：

```json
const cc=[]
for(let y=0;y<16;y+=4){
    const [ax,ay,az,aw]=[ca[y],ca[y+1],ca[y+2],ca[y+3]]
    for (let x=0;x<4;x++){
        console.log(x);
        const [bx,by,bz,bw]=[cb[x],cb[x+4],cb[x+8],cb[x+12]]
        cc.push(ax*bx+ay*by+az*bz+aw*bw)
    }
}
console.log(cc);
[
    560, 1520, 2480, 3440,
    620, 1740, 2860, 3980,
    680, 1960, 3240, 4520,
    740, 2180, 3620, 5060
]
```

### 2.变换规律

1. 位移加位移

接下来我想让一个物体沿 x 轴位移 ax，沿 y 轴位移 ay 后，再沿 x 轴位移 bx，沿 y 轴位移 by。

已知：

- 初始点位 A(ax,ay,az,1.0)
- 初次位移：沿 x 轴位移 bx，沿 y 轴位移 by
- 第二次位移：沿 x 轴位移 cx，沿 y 轴位移 cy

求：变换后的位置 F(fx,fy,fz,fw)

解：

1.设初次变换矩阵为 bm(行主序)：

```json
bm
[
	1.0,0.0,0.0,bx,
	0.0,1.0,0.0,by,
	0.0,0.0,1.0,0.0,
	0.0,0.0,0.0,1.0,
]
```

则初次变换后的点 F 为：

```js
F = bm * A;
fx = (1.0, 0.0, 0.0, bx) * (ax, ay, az, 1.0) = ax + bx;
fy = (0.0, 1.0, 0.0, by) * (ax, ay, az, 1.0) = ay + by;
fz = (0.0, 0.0, 1.0, 0.0) * (ax, ay, az, 1.0) = az;
fw = (0.0, 0.0, 0.0, 1.0) * (ax, ay, az, 1.0) = 1.0;
```

2.设第二次变换矩阵为 cm(行主序)：

```json
cm
[
	1.0,0.0,0.0,cx,
	0.0,1.0,0.0,cy,
	0.0,0.0,1.0,0.0,
	0.0,0.0,0.0,1.0,
]
```

则第二次变换后的点 F 为第二次变换矩阵乘以上一次变换后的点 F：

```js
F = cm * F;
fx = (1.0, 0.0, 0.0, cx) * (fx, fy, fz, 1.0) = fx + cx;
fy = (0.0, 1.0, 0.0, cy) * (fx, fy, fz, 1.0) = fy + cy;
fz = (0.0, 0.0, 1.0, 0.0) * (fx, fy, fz, 1.0) = fz;
fw = (0.0, 0.0, 0.0, 1.0) * (fx, fy, fz, 1.0) = 1.0;
```

所以理解最终的点 F：

```js
fx = ax + bx + cx;
fy = ay + by + cy;
fz = az;
fw = 1.0;
```

上面的点 F 还可以这么理解：（矩阵乘以矩阵）

```js
F = cm * bm * A;
```

设 cm\*bm 的结果为矩阵 dm(行主序)，参照 dm 中元素的索引位置：

```json
cm
[
    0, 1, 2, 3,
	4, 5, 6, 7,
	8, 9,10,11,
	12,13,14,15,
]
```

则 dm 中的第一行元素为：

```js
dm[0] = (1.0, 0.0, 0.0, bx) * (1.0, 0.0, 0.0, 0.0) = 1.0;
dm[1] = (1.0, 0.0, 0.0, bx) * (0.0, 1.0, 0.0, 0.0) = 0.0;
dm[2] = (1.0, 0.0, 0.0, bx) * (0.0, 0.0, 1.0, 0.0) = 0.0;
dm[3] = (1.0, 0.0, 0.0, bx) * (cx, cy, 0.0, 1.0) = cx + bx;
```

通过 dm 矩阵的第一行元素我们就可以得到点 F 的 fx 值了，我们验证一下：

```js
fx = (1.0, 0.0, 0.0, cx + bx) * (ax, ay, az, 1.0) = ax + cx + bx;
```

这和我们之前两次矩阵乘以向量得到的结果是一样的。

2. 先移动后旋转

```js
const mr = new Matrix4();
mr.makeRotationZ(Math.PI / 4);

const mt = new Matrix4();
mt.makeTranslation(0.3, 0, 0);

const matrix = mr.multiply(mt);
const u_Matrix = gl.getUniformLocation(gl.program, "u_Matrix");
gl.uniformMatrix4fv(u_Matrix, false, matrix.elements);
```

mr.multiply(mt) 便是先位移再旋转：  
![](../img/2021/1220/23.png)

3. 先旋转后移动

```js
const mr = new Matrix4();
mr.makeRotationZ(Math.PI / 4);

const mt = new Matrix4();
mt.makeTranslation(0.3, 0, 0);

const matrix = mt.multiply(mr);
const u_Matrix = gl.getUniformLocation(gl.program, "u_Matrix");
gl.uniformMatrix4fv(u_Matrix, false, matrix.elements);
```

mt.multiply(mr)便是先旋转再位移：  
![](../img/2021/1220/24.png)

4. 其它变换方式

1)旋转和缩放

- 先旋转后缩放

```js
const mr = new Matrix4();
mr.makeRotationZ(Math.PI / 4);

const ms = new Matrix4();
ms.makeScale(2, 0.5, 1);

const matrix = ms.multiply(mr);
const u_Matrix = gl.getUniformLocation(gl.program, "u_Matrix");
gl.uniformMatrix4fv(u_Matrix, false, matrix.elements);
```

- 先缩放后旋转

```js
const matrix = mr.multiply(ms);
```

在此要注意一个性质：当缩放因子一致时，旋转和缩放没有先后之分。

```js
const ms = new Matrix4();
ms.makeScale(2, 2, 2);
```

此是下面的两种变换结果都是一样的:

```js
const matrix = ms.multiply(mr);
const matrix = mr.multiply(ms);
```

2)综合变换

Matrix4 还有一个 compose 综合变换方法，它可以将所有变换信息都写进去，其变换顺序就是先缩放，再旋转，最后位移。

```js
const matrix = new Matrix4();
//位移
const pos = new Vector3(0.3, 0, 0);
//旋转
const rot = new Quaternion();
rot.setFromAxisAngle(new Vector3(0, 0, 1), Math.PI / 4);
//缩放
const scale = new Vector3(2, 0.5, 1);
matrix.compose(pos, rot, scale);
const u_Matrix = gl.getUniformLocation(gl.program, "u_Matrix");
gl.uniformMatrix4fv(u_Matrix, false, matrix.elements);
```

compose ( position : Vector3, quaternion : Quaternion, scale : Vector3 )

- position 位置
- quaternion 用四元数存储的旋转数据
- scale 缩放

compose() 方法分解开来，就是这样的：

```js
const mt = new Matrix4();
mt.makeTranslation(0.3, 0, 0);

const mr = new Matrix4();
mr.makeRotationZ(Math.PI / 4);

const ms = new Matrix4();
ms.makeScale(2, 0.5, 1);

const matrix = mt.multiply(mr).multiply(ms);
const u_Matrix = gl.getUniformLocation(gl.program, "u_Matrix");
gl.uniformMatrix4fv(u_Matrix, false, matrix.elements);
```

### 3.视图矩阵

视图矩阵是用于确定相机角度和位置的矩阵，最终改变的是场景中的物体

#### 1.相机的定义

![](../img/2021/1220/25.png)

- 视点：相机的位置
- 视线方向：相机所看的方向
- 上方向：相机绕视线转动的方向

#### 2.相对运动

当相机与它所拍摄的物体同时运动的时候，相机所拍摄的画面不会有任何改变

![](../img/2021/1220/26.png)

因此，我们可以默认相机的视点就在零点，相机看向-z 方向，其上方向就是 y 轴。  
当我我们改变的相机的视点、视线和上方向的时候，只要相对的去改变场景中的物体即可。  
而这个相对的去改变场景中的物体的矩阵，就是视图矩阵。

![](../img/2021/1220/27.png)

通过上面原理可以知道，想要计算视图矩阵，让其满足以下条件即可：

1. 把视点 e(ex,ey,ez)对齐到 O 点上
2. 把视线 c(cx,cy,cz) 旋转到-z 轴上
3. 把上方向 b(bx,by,bz) 旋转到 y 轴上
4. 把 c 与 b 的垂线 a(ax,ay,az) 旋转到 x 轴上

#### 3.正交矩阵的旋转

为了理解视图矩阵的运算，从几个例题说起。

题 1  
已知：点 A(1,0,0)  
求：把点 A 绕 z 轴逆时针旋转 30°，旋转到 B 点的行主序矩阵 m1  
![](../img/2021/1220/28.png)

```js
m1=[
	cos30°,-sin30°,0,0,
	sin30°,cos30°, 0,0,
	0,     0,      1,0,
	0,     0,      0,1,
]
B=m1*A
B.x=(cos30°,-sin30°,0,0)·(1,0,0,1)=cos30°
B.y=(sin30°,cos30°, 0,0)·(1,0,0,1)=sin30°
```

题 2  
继题 1 的已知条件  
求：把点 B 绕 z 轴逆时针旋转-30°，旋转到 A 点的列行序矩阵 m2

```js
m2=[
	cos-30°,-sin-30°,0,0,
	sin-30°,cos-30°, 0,0,
	0,      0,       1,0,
	0,      0,       0,1,
]
m2=[
	cos30°, sin30°,  0,0,
	-sin30°,cos30°,  0,0,
	0,      0,       1,0,
	0,      0,       0,1,
]
```

观察题 1、题 2，我们可以发现两个规律：

- m2 是 m1 的逆矩阵
- m2 也是 m1 的转置矩阵

由此我们可以得到一个结论：**正交旋转矩阵的逆矩阵就是其转置矩阵**。

题 3  
已知：

- 三维直角坐标系 m1，其基向量是：

  - x(1,0,0)
  - y(0,1,0)
  - z(0,0,1)

- 三维直角坐标系 m2，其基向量是：
  - x(cos30°, sin30°,0)
  - y(-sin30°,cos30°,0)
  - z(0, 0, 1)

求：将 m1 中的基向量对齐到 m2 的行主序矩阵 m3  
![](../img/2021/1220/29.png)

解：

将 m2 的基向量 x,y,z 中的 x 分量写入 m3 第 1 行;  
将 m2 的基向量 x,y,z 中的 y 分量写入 m3 第 2 行;  
将 m2 的基向量 x,y,z 中的 z 分量写入 m3 第 3 行。

```js
m3=[
	cos30°,-sin30°,0,0,
	sin30°,cos30°, 0,0,
	0,     0,      1,0,
	0,     0,      0,1,
]
```

题 4  
继题 3 的已知条件  
求：将 m2 中的基向量对齐到 m1 的行主序矩阵 m4

解：  
由题 3 已知：将 m1 中的基向量对齐到 m2 的行主序矩阵是 m3  
由题 4 的问题可知：m4 就是 m3 的逆矩阵  
因为：正交旋转矩阵的逆矩阵就是其转置矩阵  
所以：m4 就是 m3 的转置矩阵

```js
m3=[
	cos30°,-sin30°,0,0,
	sin30°,cos30°, 0,0,
	0,     0,      1,0,
	0,     0,      0,1,
]
m4=[
	cos30°,sin30°,0,0,
	-sin30°,cos30°,0,0,
	0,0,1,0,
	0,0,0,1
]
```

#### 4.计算视图矩阵

![](../img/2021/1220/30.png)

1. 先位移：写出把视点 e(ex,ey,ez) 对齐到 O 点上的行主序位移矩阵 mt

```json
mt
mt=[
  1,0,0,-ex,
  0,1,0,-ey,
  0,0,1,-ez,
  0,0,0,1,
]
```

2. 写出把{o;x,y,-z} 对齐到{e;a,b,c} 的行主序旋转矩阵 mr1

把 a,b,-c 的 x 分量写入 mr1 的第 1 行；  
​ 把 a,b,-c 的 y 分量写入 mr1 的第 2 行；  
​ 把 a,b,-c 的 z 分量写入 mr1 的第 3 行；

```json
mr1
mr1=[
	 ax, bx, -cx, 0,
	 ay, by, -cy, 0,
	 az, bz, -cz, 0,
	 0,  0,   0,  1
]
```

3. 计算 mr1 的逆矩阵 mr2。

因为正交旋转矩阵的逆矩阵就是其转置矩阵，所以 mr2 就是 mr1 的转置矩阵。

```json
mr2
mr2=[
	 ax, ay, az, 0,
	 bx, by, bz, 0,
	-cx,-cy,-cz, 0,
	 0,  0,   0, 1
]
```

4. 视图投影矩阵=mr2\*mt

#### 5.视图矩阵的代码实现

![](../img/2021/1220/30.png)

基于视点、目标点、上方向生成视图矩阵。

```json
getViewMatrix 相当于 threeJS 的 lookAt 方法
function getViewMatrix(e, t, u) {
  //基向量c，视线
  const c = new Vector3().subVectors(e, t).normalize()
  //基向量a，视线和上方向的垂线
  const a = new Vector3().crossVectors(u, c).normalize()
  //基向量b，修正上方向
  const b = new Vector3().crossVectors(c, a).normalize()
  //正交旋转矩阵
  const mr = new Matrix4().set(
    ...a, 0,
    ...b, 0,
    -c.x, -c.y, -c.z, 0,
    0, 0, 0, 1
  )
  //位移矩阵
  const mt = new Matrix4().set(
    1, 0, 0, -e.x,
    0, 1, 0, -e.y,
    0, 0, 1, -e.z,
    0, 0, 0, 1
  )
  return mr.multiply(mt).elements
}
```

getViewMatrix 方法就是从一个新的角度去看某一个东西的意思

- e 视点
- t 目标点
- u 上方向

在其中我借助了 Three.js 的 Vector3 对象

- subVectors(e, t) 向量 e 减向量 t
- normalize() 向量的归一化
- crossVectors(u, d) 向量 u 和向量 d 的叉乘

```js
crossVectors( a, b ) {
  const ax = a.x, ay = a.y, az = a.z;
  const bx = b.x, by = b.y, bz = b.z;
  this.x = ay * bz - az * by;
  this.y = az * bx - ax * bz;
  this.z = ax * by - ay * bx;
  return this;
}
```

解释一下上面基向量 a,b,c 的运算原理，以下图为例：

![](../img/2021/1220/31.png)

视线 c 之所以是视点 e 减目标点 t，是为了取一个正向的基向量。

```js
c=(e-t)/|e-t|
c=(0,0,2)/2
c=(0,0,1)
```

基向量 a 是上方向 u 和向量 c 的叉乘

```js
a=u^c/|u^c|
a=(cos30°,0,0)/cos30°
a=(1,0,0)
```

基向量 b 是向量 c 和向量 a 的叉乘，可以理解为把上方向摆正

```js
b=c^a/|c^a|
b=(0,1,0)/1
b=(0,1,0)
```

#### 6.测试

1. 顶点着色器

```js
<script id="vertexShader" type="x-shader/x-vertex">
    attribute vec4 a_Position;
    //视图矩阵
    uniform mat4 u_ViewMatrix;
    void main(){
      gl_Position = u_ViewMatrix*a_Position;
    }
</script>
```

2. 建立视图矩阵，并传递给顶点着色器

```js
const u_ViewMatrix = gl.getUniformLocation(gl.program, "u_ViewMatrix");
const viewMatrix = getViewMatrix(
  new Vector3(0.3, 0.2, 0.5),
  new Vector3(0.0, 0.1, 0),
  new Vector3(0, 1, 0)
);
gl.uniformMatrix4fv(u_ViewMatrix, false, viewMatrix);
```

注：

three.js 里的 lookAt() 方法便可以实现矩阵的正交旋转，其参数也是视点、目标点、上方向，它的实现原理上面说的是一样的。

```js
const u_ViewMatrix = gl.getUniformLocation(gl.program, "u_ViewMatrix");
const viewMatrix = new Matrix4().lookAt(
  new Vector3(0.5, 0.5, 1),
  new Vector3(0, 0, 0),
  new Vector3(0, 1, 0)
);
gl.uniformMatrix4fv(u_ViewMatrix, false, viewMatrix.elements);
```

### 4.模型矩阵

模型矩阵可以对物体进行位移、旋转、缩放变换，比如我们想让物体沿 z 旋转

代码实现：

1. 在顶点着色器中添加一个模型矩阵

```js
<script id="vertexShader" type="x-shader/x-vertex">
    attribute vec4 a_Position;
    //模型矩阵
    uniform mat4 u_ModelMatrix;
    //视图矩阵
    uniform mat4 u_ViewMatrix;
    void main(){
      gl_Position = u_ViewMatrix*u_ModelMatrix*a_Position;
    }
</script>
```

2. 在 js 中建立模型矩阵，并传递给顶点着色器

```js
const u_ModelMatrix = gl.getUniformLocation(gl.program, "u_ModelMatrix");
const u_ViewMatrix = gl.getUniformLocation(gl.program, "u_ViewMatrix");

const modelMatrix = new Matrix4();
const viewMatrix = new Matrix4().lookAt(
  new Vector3(0, 0.25, 1),
  new Vector3(0, 0, 0),
  new Vector3(0, 1, 0)
);

gl.uniformMatrix4fv(u_ModelMatrix, false, modelMatrix.elements);
gl.uniformMatrix4fv(u_ViewMatrix, false, viewMatrix.elements);
```

3. 添加一个旋转动画

```js
let angle = 0;
!(function ani() {
  angle += 0.02;
  modelMatrix.makeRotationY(angle);
  gl.uniformMatrix4fv(u_ModelMatrix, false, modelMatrix.elements);

  gl.clear(gl.COLOR_BUFFER_BIT);
  gl.drawArrays(gl.LINES, 0, indices.length);
  requestAnimationFrame(ani);
})();
```

4. 还可以来个弹性动画

```js
let angle = 0;

const minY = -0.7;
const maxY = 0.7;
let y = maxY;
let vy = 0;
const ay = -0.001;
const bounce = 1;

!(function ani() {
  angle += 0.01;
  vy += ay;
  y += vy;
  modelMatrix.makeRotationY(angle);
  modelMatrix.setPosition(0, y, 0);
  if (modelMatrix.elements[13] < minY) {
    y = minY;
    vy *= -bounce;
  }

  gl.uniformMatrix4fv(u_ModelMatrix, false, modelMatrix.elements);
  gl.clear(gl.COLOR_BUFFER_BIT);
  gl.drawArrays(gl.LINES, 0, indices.length);
  requestAnimationFrame(ani);
})();
```

## 七、颜色与纹理

### 1.多 attribute 变量

如何一次性绘制三个不同颜色的点？

1. 多点同色

```html
<canvas id="canvas"></canvas>
<!-- 顶点着色器 -->
<script id="vertexShader" type="x-shader/x-vertex">
  attribute vec4 a_Position;
  void main(){
      //点位
      gl_Position=a_Position;
      //尺寸
      gl_PointSize=50.0;
  }
</script>
<!-- 片元着色器 -->
<script id="fragmentShader" type="x-shader/x-fragment">
  precision mediump float;
  uniform vec4 u_FragColor;
  void main(){
      gl_FragColor=u_FragColor;
  }
</script>
<script type="module">
  const u_FragColor = gl.getUniformLocation(gl.program, "u_FragColor");
  gl.uniform4f(u_FragColor, 1, 0, 1, 1);
</script>
```

这种方式只会绘制三个同样颜色的点。  
那我们若想给这三个点不同的颜色，就需要再建立一个接收颜色数据的 attribute 变量。

2. 多点异色

```json
<canvas id="canvas"></canvas>
<!-- 顶点着色器 -->
<script id="vertexShader" type="x-shader/x-vertex">
  attribute vec4 a_Position;
  attribute vec4 a_Color;
  varying vec4 v_Color;
  void main(){
      //点位
      gl_Position=a_Position;
      //尺寸
      gl_PointSize=50.0;
      v_Color=a_Color;
  }
</script>
<!-- 片元着色器 -->
<script id="fragmentShader" type="x-shader/x-fragment">
  precision mediump float;
  varying vec4 v_Color;
  void main(){
      gl_FragColor=v_Color;
  }
</script>
<script type="module">
  import { initShaders } from "../jsm/Utils.js";

  const canvas = document.querySelector("#canvas");
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;

  // 获取着色器文本
  const vsSource = document.querySelector("#vertexShader").innerText;
  const fsSource = document.querySelector("#fragmentShader").innerText;

  //三维画笔
  const gl = canvas.getContext("webgl");

  //初始化着色器
  initShaders(gl, vsSource, fsSource);
  //声明颜色 rgba
  gl.clearColor(0, 0, 0, 1);

  //如何向attribute 变量中写入多点，并绘制多点
  //顶点数据
  const vertices = new Float32Array([
    0, 0.2,
    -0.2, -0.1,
    0.2, -0.1,
  ]);
  //缓冲对象
  const vertexBuffer = gl.createBuffer();
  //绑定缓冲对象
  gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
  //写入数据
  gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW)
  //获取attribute 变量
  const a_Position = gl.getAttribLocation(gl.program, 'a_Position')
  //修改attribute 变量
  gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 0, 0)
  //赋能-批处理
  gl.enableVertexAttribArray(a_Position)


  //颜色数据
  const colors = new Float32Array([
    0, 0, 1, 1,
    0, 1, 0, 1,
    1, 1, 0, 1
  ]);
  //缓冲对象
  const colorBuffer = gl.createBuffer();
  //绑定缓冲对象
  gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
  //写入数据
  gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW)
  //获取attribute 变量
  const a_Color = gl.getAttribLocation(gl.program, 'a_Color')
  //修改attribute 变量
  gl.vertexAttribPointer(a_Color, 4, gl.FLOAT, false, 0, 0)
  //赋能-批处理
  gl.enableVertexAttribArray(a_Color)

  //刷底色
  gl.clear(gl.COLOR_BUFFER_BIT);

  //绘制顶点
  gl.drawArrays(gl.POINTS, 0, 3);
</script>
```

在上面的案例里，用 js 建立了两份 attribute 数据，一份是顶点位置数据，一份是顶点颜色数据。  
然后将两份 attribute 数据放进了了两个缓冲区对象里，后面绘图的时候，顶点着色器就会从这里面找数据。  
其实，也可以把数据合一下，把点位数据和颜色数据放进一个集合里，然后让 attribute 变量按照某种规律从其中寻找数据。

3. 多 attribute 数据合一

```json
<canvas id="canvas"></canvas>
<!-- 顶点着色器 -->
<script id="vertexShader" type="x-shader/x-vertex">
  attribute vec4 a_Position;
  attribute vec4 a_Color;
  varying vec4 v_Color;
  void main(){
      //点位
      gl_Position=a_Position;
      //尺寸
      gl_PointSize=50.0;
      v_Color=a_Color;
  }
</script>
<!-- 片元着色器 -->
<script id="fragmentShader" type="x-shader/x-fragment">
  precision mediump float;
  varying vec4 v_Color;
  void main(){
      gl_FragColor=v_Color;
  }
</script>
<script type="module">
  import { initShaders } from "../jsm/Utils.js";

  const canvas = document.querySelector("#canvas");
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;

  // 获取着色器文本
  const vsSource = document.querySelector("#vertexShader").innerText;
  const fsSource = document.querySelector("#fragmentShader").innerText;

  //三维画笔
  const gl = canvas.getContext("webgl");

  //初始化着色器
  initShaders(gl, vsSource, fsSource);
  //声明颜色 rgba
  gl.clearColor(0, 0, 0, 1);

  //数据源
  const source = new Float32Array([
    0, 0.4, 0, 0, 0, 1, 1,
    -0.2, -0.1, 0, 0, 1, 0, 1,
    0.2, -0.1, 0, 1, 1, 0, 1,
  ]);
  //元素字节数
  const elementBytes = source.BYTES_PER_ELEMENT
  //系列尺寸
  const verticeSize = 3
  const colorSize = 4
  //类目尺寸
  const categorySize = verticeSize + colorSize
  //类目字节数
  const categoryBytes = categorySize * elementBytes
  //系列字节索引位置
  const verticeByteIndex = 0
  const colorByteIndex = verticeSize * elementBytes
  //顶点总数
  const sourceSize = source.length / categorySize


  //缓冲对象
  const sourceBuffer = gl.createBuffer();
  //绑定缓冲对象
  gl.bindBuffer(gl.ARRAY_BUFFER, sourceBuffer);
  //写入数据
  gl.bufferData(gl.ARRAY_BUFFER, source, gl.STATIC_DRAW)

  //获取attribute 变量
  const a_Position = gl.getAttribLocation(gl.program, 'a_Position')
  //修改attribute 变量
  gl.vertexAttribPointer(
    a_Position,
    verticeSize,
    gl.FLOAT,
    false,
    categoryBytes,
    verticeByteIndex
  )
  //赋能-批处理
  gl.enableVertexAttribArray(a_Position)

  //获取attribute 变量
  const a_Color = gl.getAttribLocation(gl.program, 'a_Color')
  //修改attribute 变量
  gl.vertexAttribPointer(
    a_Color,
    colorSize,
    gl.FLOAT,
    false,
    categoryBytes,
    colorByteIndex
  )
  //赋能-批处理
  gl.enableVertexAttribArray(a_Color)

  //刷底色
  gl.clear(gl.COLOR_BUFFER_BIT);

  //绘制顶点
  gl.drawArrays(gl.POINTS, 0, sourceSize);
</script>
```

对应上面的数据，我们要先有以下概念：

- 数据源：整个合而为一的数据 source
- 元素字节数：32 位浮点集合中每个元素的字节数
- 类目：一个顶点对应一个类目，也就是上面 source 中的每一行
- 系列：一个类目中所包含的每一种数据，比如顶点位置数据、顶点颜色数据
- 系列尺寸：一个系列所对应的向量的分量数目
- 类目尺寸：一个类目中所有系列尺寸的总和
- 类目字节数：一个类目的所有字节数量
- 系列元素索引位置：一个系列在一个类目中，以集合元素为单位的索引位置
- 系列字节索引位置：一个系列在一个类目中，以字节为单位的索引位置
- 顶点总数：数据源中的顶点总数

vertexAttribPointer() 方法玩转数据源：

- 以前在说 vertexAttribPointer() 的时候，说过它的功能就是让 gl 修改 attribute 上下文对象的。
- 其实具体而言，它是在告诉顶点着色器中的 attribute 变量以怎样的方式从顶点着色器中寻找它所需要的数据。
- 比如，我想让顶点着色器中，名叫 a_Position 的 attribute 的变量从数据源中，寻找它所需要的数据。

gl.vertexAttribPointer(index, size, type, normalized, stride, offset)

- index：attribute 变量，具体而言是指向存储 attribute 变量的空间的指针
- size：系列尺寸
- type：元素的数据类型
- normalized：是否归一化
- stride：类目字节数
- offset：系列索引位置

### 2.彩色三角形

可以用独立三角形绘图：

```js
gl.drawArrays(gl.TRIANGLES, 0, sourseSize);
```

效果如下：

![](../img/2021/1220/32.png)

原理：  
三角形的三个顶点绑定了三种颜色，在三个点之间做线性补间，将补间得出的颜色填充到三角形所围成的每个片元之中。

![](../img/2021/1220/33.gif)

### 3.纹理

纹理，通常指的就是二维的栅格图像，可以将其作为 webgl 图形的贴图。

而在 webgl 里，还有一个纹理对象的概念，它是对图像又做了一层封装。

#### 1.基础概念

1. 栅格系统

在说图像的时候，往往都是指点阵图、栅格图、位图，而与其相对应的是图形，也做矢量图。

纹理，就是属于图像，其图像的建立和显示会遵循栅格系统里的规范

所有图像都是由像素组成的，在 webgl 里我们把像素称为片元，像素是按照相互垂直的行列排列的

如下图：  
![](../img/2021/1220/34.png)

将其放大后就可以看见其中的栅格：  
![](../img/2021/1220/35.png)

图像中的每个像素都可以通过行数 y 和列数 x 来找到，由(x,y) 构成的点位，就是图像的像素坐标。

因为 canvas 画布也是一张图像，所以图像的栅格坐标系和我们之前说过的 canvas2d 的坐标系是一样的，我们可以简单回顾一下：

![](../img/2021/1220/2.png)

栅格坐标系的原点在左上角。  
栅格坐标系的 y 轴方向是朝下的。  
栅格坐标系的坐标基底由两个分量组成，分别是一个像素的宽和一个像素的高。

2. 图钉

图钉是我自己写的概念，源自于 photoshop 中图像的操控变形功能，这种称呼很形象。

![](../img/2021/1220/36.png)

webgl 中，图钉的位置是通过 uv 坐标来控制的，图钉的 uv 坐标和顶点的 webgl 坐标是两种不同的坐标系统，之后会将其相互映射，从而将图像特定的一块区域贴到 webgl 图形中。

比如将其映射到下面的蓝色三角形中：  
![](../img/2021/1220/37.png)

注：在 webgl 里打图钉的时候不会发生边界线的扭曲，上图重在示意。

3. uv 坐标系

![](../img/2021/1220/38.png)

uv 坐标系，也叫 st 坐标系，坐标原点在图像的左下角，u 轴在右，v 轴在上  
u 轴上的 1 个单位是图像的宽；  
v 轴上的一个单位是图像的高。

4. 采样器

采样器是按照图钉位置从图像中获取片元的方式。

在图像中所打的图钉位置，并不是图像中某一个片元的位置，因为片元位置走的是栅格坐标系。

所以需要一个采样器去对图钉的 uv 坐标系和像素的栅格坐标系做映射，从而去采集图像中图钉所对应的片元。

着色器基于一张图像可以建立一个或多个采样器，不同的采样器可以定义不同的规则去获取图像中的片元。

采样器在着色器中是一种变量类型，写做 sampler2D，它就像我们之前写过的 vec4 类型一样，可以在片元着色器中通过 uniform 变量暴露给 js，让 js 对其进行修改。

5. 纹理对象

着色器使用一个纹理对象，就可以建立一个采样器。

纹理对象的建立需要一个图像源，比如 Image 对象。

同时，还需要设置纹理对象和图钉进行数据映射的方式。

js => 纹理对象，webgl => 缓冲区  
缓存区用于存放纹理对象的磁盘空间，这块空间可以将纹理对象翻译成着色器可以读懂的数据。  
之后会把这个空间的索引位置传给着色器，让着色器基于这个空间的索引位置，找到这个空间，然后再从空间中找到纹理对象，最后通过纹理对象建立采样器。

6. 纹理单元

纹理单元是一种专门用来存放纹理对象的缓冲区，就像我们之前用 createBuffer()方法建立的用于存储数据源的缓冲区一样。

webgl=> 纹理单元，如 TEXTURE0|1|2|3|4|5|6|7|

纹理单元虽然无需我们自己建立，但需要我们自己激活，让其进入使用状态

#### 2.整体代码

1. 顶点着色器

```js
<script id="vertexShader" type="x-shader/x-vertex">
    attribute vec4 a_Position;
    attribute vec2 a_Pin;
    varying vec2 v_Pin;
    void main(){
      gl_Position = a_Position;
      v_Pin=a_Pin;
    }
</script>
```

- a_Pin 图钉位置

2. 片元着色器

```js
<script id="fragmentShader" type="x-shader/x-fragment">
    precision mediump float;
    uniform sampler2D u_Sampler;
    varying vec2 v_Pin;
    void main(){
      gl_FragColor=texture2D(u_Sampler,v_Pin);
    }
</script>
```

- sampler2D 是 uniform 变量的类型，叫做二维取样器
- texture2D() 基于图钉从取样器中获取片元颜色

3. 初始化着色器

```js
const canvas = document.getElementById("canvas");
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;
const gl = canvas.getContext("webgl");

const vsSource = document.getElementById("vertexShader").innerText;
const fsSource = document.getElementById("fragmentShader").innerText;
initShaders(gl, vsSource, fsSource);
gl.clearColor(0.0, 0.0, 0.0, 1.0);
```

4. 建立数据源，并计算相应尺寸

```json
//数据源
const source = new Float32Array([
    -0.5, 0.5, 0.0, 1.0,
    -0.5, -0.5, 0.0, 0.0,
    0.5, 0.5, 1.0, 1.0,
    0.5, -0.5, 1.0, 0.0,
]);
const FSIZE = source.BYTES_PER_ELEMENT;
//元素字节数
const elementBytes = source.BYTES_PER_ELEMENT
//系列尺寸
const posSize = 2
const PinSize = 2
//类目尺寸
const categorySize = posSize + PinSize
//类目字节数
const categoryBytes = categorySize * elementBytes
//系列字节索引位置
const posByteIndex = 0
const pinByteIndex = posSize * elementBytes
//顶点总数
const sourceSize = source.length / categorySize
```

数据源中有两个系列，分别是顶点位置系列和图钉位置系列。

5. 将数据源写入到缓冲区，让 attribute 变量从其中寻找数据

```js
const sourceBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, sourceBuffer);
gl.bufferData(gl.ARRAY_BUFFER, source, gl.STATIC_DRAW);

const a_Position = gl.getAttribLocation(gl.program, "a_Position");
gl.vertexAttribPointer(
  a_Position,
  posSize,
  gl.FLOAT,
  false,
  categoryBytes,
  posByteIndex
);
gl.enableVertexAttribArray(a_Position);

const a_Pin = gl.getAttribLocation(gl.program, "a_Pin");
gl.vertexAttribPointer(
  a_Pin,
  pinSize,
  gl.FLOAT,
  false,
  categoryBytes,
  pinByteIndex
);
gl.enableVertexAttribArray(a_Pin);
```

6. 建立 Image 图像作为图像源，当图像源加载成功后再贴图

```js
//对纹理图像垂直翻转
gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1);

//激活0号纹理单元
gl.activeTexture(gl.TEXTURE0);

//纹理对象
const texture = gl.createTexture();
//把纹理对象装进纹理单元里
gl.bindTexture(gl.TEXTURE_2D, texture);

//image 对象
const image = new Image();
image.src = "./images/erha2.jpg";
image.onload = function() {
  showMap();
};

//贴图
function showMap() {
  //配置纹理图像
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, image);

  //配置纹理参数
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);

  //获取u_Sampler
  const u_Sampler = gl.getUniformLocation(gl.program, "u_Sampler");
  //将0号纹理分配给着色器，0 是纹理单元编号
  gl.uniform1i(u_Sampler, 0);

  //渲染
  render();
}

function render() {
  gl.clear(gl.COLOR_BUFFER_BIT);
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, sourceSize);
}
```

#### 3.贴图详解

1. 准备三个角色

- Image 图像
- 纹理对象
- 纹理单元

![](../img/2021/1220/39.png)

```js
// 激活0号纹理单元
gl.activeTexture(gl.TEXTURE0);

//纹理对象
const texture = gl.createTexture();

//image 对象
const image = new Image();
image.src = "./images/erha.jpg";
```

2. 把纹理对象装进当前已被激活的纹理单元里

![](../img/2021/1220/40.png)

```js
const texture = gl.createTexture();
gl.bindTexture(gl.TEXTURE_2D, texture);
```

- TEXTURE_2D 纹理对象的类型

3. 当 Image 图像加载成功后，把图像装进当前纹理单元的纹理对象里

![](../img/2021/1220/41.png)

```js
gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, image);
```

texImage2D(type, level, internalformat, format, type, pixels)

- type 纹理类型
- level 基本图像等级
- internalformat 纹理中的颜色组件
- format 纹理数据格式，必须和 internalformat 一样
- type 纹理数据的数据类型
  - UNSIGNED_BYTE 无符号字节
- pixels 图像源

4. 纹理对象还有一些相应参数需要设置一下

```js
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
```

texParameteri(type, pname, param)

- type 纹理类型
  - TEXTURE_2D 二维纹理
- pname 纹理参数的名称
  - TEXTURE_MIN_FILTER 纹理缩小滤波器
- param 与 pname 相对应的纹理参数值
  - gl.LINEAR 线性

5. 在 js 中获取采样器对应的 Uniform 变量,告诉片元着色器中的采样器，纹理对象在哪个单元里。之后采样器便会根据单元号去单元对象中寻找纹理对象

![](../img/2021/1220/42.png)

```js
const u_Sampler = gl.getUniformLocation(gl.program, "u_Sampler");
gl.uniform1i(u_Sampler, 0);
```

6. 渲染

```js
render();
function render() {
  gl.clear(gl.COLOR_BUFFER_BIT);
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, sourceSize);
}
```

效果如下：  
![](../img/2021/1220/43.png)  
这时候的图像是倒立的，这是由于 Image 对象遵守的是栅格坐标系，栅格坐标系的 y 轴朝下，而 uv 坐标系的 y 朝上，两者相反，所以画出的图形反了。

7. 对图像进行预处理，将图像垂直翻转

```js
gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1);
```

pixelStorei(pname, param) 图像预处理

- pname 参数名
  - gl.UNPACK_FLIP_Y_WEBGL 是否垂直翻，布尔值，1|0
- param 参数值

![](../img/2021/1220/44.png)

#### 4.纹理容器

在贴图的时候，默认图像源的尺寸只能是 2 的 n 次方，比如 2、4、8、16、……、256、512 等，如果我们把图像的尺寸改成非 2 次幂尺寸，如 300\*300，那贴图就无法显示。

要想解决这种问题，就得设置一下纹理的容器，在图像上打图钉的时候，形成一块 uv 区域，这块区域可以理解为纹理容器。纹理容器可以定义图钉区域的纹理如何显示在 webgl 图形中。通过对纹理容器的设置，我们可以实现以下功能：

- 非二次幂图像源的显示
- 纹理的复制
- 纹理的镜像

1. 非二次幂图像源的显示

```js
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
```

TEXTURE_WRAP_S 和 TEXTURE_WRAP_T 就是纹理容器在 s 方向和 t 方向的尺寸，这里的 s、t 就是 st 坐标系里的 s、t，st 坐标系和 uv 坐标系是一回事。

CLAMP_TO_EDGE 翻译过来就是边缘夹紧的意思，可以理解为任意尺寸的图像源都可以被宽高为 1 的 uv 尺寸夹紧。

注：只有 CLAMP_TO_EDGE 才能实现非二次幂图像源的显示，其它的参数都不可以。

2. 纹理的复制

uv 坐标系的坐标基底分别是 1 个图片的宽和 1 个图片的高，可是如果我们将 2 个图片的宽高映射到了图形上会是什么结果呢？

默认是这样的：  
![](../img/2021/1220/45.png)

```js
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
```

REPEAT 就是纹理重复的意思

3. 纹理的镜像复制
   纹理的镜像复制可以实现纹理的水平、垂直翻转和复制。

效果如下：  
![](../img/2021/1220/46.png)

```js
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.MIRRORED_REPEAT);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.MIRRORED_REPEAT);
```

MIRRORED_REPEAT 就是镜像复制的意思。

也可以通过使用 CLAMP_TO_EDGE 只对某一个方向纹理镜像复制

```js
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.MIRRORED_REPEAT);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
```

效果如下：  
![](../img/2021/1220/47.png)

#### 5.分子贴图

分子贴图 mipmap 是一种纹理映射技术。

比如：

webgl 中有一个正方形，它在 canvas 画布中显示的时候，占据了 2\*2 个像素，我们要将一个 8\*8 的图像源贴上去。

正方形中肯定不能显示图像源中的所有像素，因为它只有 2\*2=4 个像素。

在 Photoshop 中，会将图像源切割成 2 行、2 列的色块，然后将每个色块的均值交个正方形。

在 webgl 中也有类似的方法，并且它还有一层渲染性能的优化（Photoshop 底层是否有这层优化我尚且不知）。

接下来咱们就说一下这层优化优化的是什么。

先想象一个场景，我要把 1024\*1024 的图像源映射到 canvas 画布上 2\*2 的正方形中，若把图像源分割求均值会产生庞大的数据运算，我们需要想办法把和正方形相映射的图像源的尺寸降到最小，比如就是 2\*2 的。

因此，我们就需要[分子贴图](https://baike.baidu.com/item/Mipmap/3722136?fr=aladdin)了。

分子贴图是一个基于分辨率等比排列的图像集合，集合中每一项的宽高与其前一项宽高的比值都是 1/2。

如下图：

![](../img/2021/1220/48.png)

在 webgl 中，我们可以使用 gl.generateMipmap() 方法为图像源创建分子贴图，

有了分子贴图后，之前 2\*2 的正方形便会从分子集合中寻找与其分辨率最接近的分子图像。

在找到分子图像后，就需要基于 webgl 图形的片元尺寸对其分割取色了。

对于取色的方法，咱们之前说一个均值算法，其实还有其它算法

```js
//创建分子贴图
gl.generateMipmap(gl.TEXTURE_2D);
//定义从分子图像中取色的方法
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
```

gl.texParameteri()方法中的第 2 个参数和第 3 个参数是键值对的关系。

TEXTURE_MAG_FILTER 和 TEXTURE_MIN_FILTER，对应的是纹理在 webgl 图形中的缩放情况。

- TEXTURE_MAG_FILTER 纹理放大滤波器，是纹理在 webgl 图形中被放大的情况。
- TEXTURE_MIN_FILTER 纹理缩小滤波器，是纹理在 webgl 图形中被缩小的情况。

TEXTURE_MAG_FILTER 具备以下参数：

- LINEAR (默认值) ，线性滤镜， 获取纹理坐标点附近 4 个像素的加权平均值，效果平滑
- NEAREST 最近滤镜， 获得最靠近纹理坐标点的像素 ，效果锐利

TEXTURE_MIN_FILTER 具备以下参数：

- LINEAR 线性滤镜，获取纹理坐标点附近 4 个像素的加权平均值，效果平滑
- NEAREST 最近滤镜， 获得最靠近纹理坐标点的像素，效果锐利
- NEAREST_MIPMAP_NEAREST Select the nearest mip level and perform nearest neighbor filtering .
- NEAREST_MIPMAP_LINEAR (默认值) Perform a linear interpolation between mip levels and perform nearest neighbor filtering within each .
- LINEAR_MIPMAP_NEAREST Select the nearest mip level and perform linear filtering within it .
- LINEAR_MIPMAP_LINEAR Perform a linear interpolation between mip levels and perform linear filtering : also called trilinear filtering .

注：后面这 4 个与分子贴图相关的参数适合比较大的贴图，若是比较小的贴图，使用 LINEAR 或 NEAREST 就好。

注：缩小滤波器的默认值取色方法是 NEAREST_MIPMAP_LINEAR ，这个方法会从分子贴图里找分子图像，然后从其中取色，然而当我们没有使用 gl.generateMipmap()方法建立分子贴图的时候，就得给它一个不需要从分子贴图中去色的方法，如 LINEAR 或 NEAREST。

#### 6.多纹理模型

在实际开发中，经常会遇到一个模型，多个纹理的的情况。

比如这个魔方：

![](../img/2021/1220/50.gif)

有时候会很自然的想到一个面给它一个贴图，而实际上，最高效的方式是一个物体给它一个贴图，如下图：

![](../img/2021/1220/50.jpg)

这样只需要加载一次图片，建立一个纹理对象，做一次纹理和顶点数据的映射就可以了。

这里面没有涉及任何新的知识点，但这是一种很重要的项目开发经验。

### 4.纹理合成

纹理合成就是按照某种规则将多张图片合在一起。

#### 4-1 多图加载

纹理合成是需要多张图像源的，因此我们需要多张图像源都加载成功后，再去合成纹理。

1. 将图像的加载方法封装进一个 Promise 中，等图像加载成功后，再 resolve。

```js
function imgPromise(img) {
  return new Promise((resolve) => {
    img.onload = function() {
      resolve(img);
    };
  });
}
```

2. 建立多个 Image 对象

```js
const originImg = new Image();
originImg.src = "./images/dress.jpg";

const pattern = new Image();
pattern.src = "./images/pattern1.jpg";
```

3. 利用 Promise.all 监听所有图片的记载成功

```js
Promise.all([imgPromise(originImg), imgPromise(pattern)]).then(() => {
  rect.maps = {
    u_Sampler: { image: originImg },
    u_Pattern: { image: pattern },
  };
  rect.updateMaps();
  render();
});
```

等所有的图片都加载成功后，会往 rect 的 maps 集合里写入贴图，然后对其更新和渲染。

接下来，看一下纹理合成最核心的地方，片元着色器。

#### 4-2 在片元着色器中合成纹理

片元着色器：

```js
<script id="fragmentShader" type="x-shader/x-fragment">  
  precision mediump float;  
  uniform sampler2D u_Sampler;  
  uniform sampler2D u_Pattern;  
  varying vec2 v_Pin;  
  void main(){    
    vec4 o=texture2D(u_Sampler,v_Pin);    
    vec4 p=texture2D(u_Pattern,v_Pin);    
    gl_FragColor=p*o;  
  }
</script>
```

- u_Sampler 是原始图片采样器，对应下图：

![](../img/2021/1220/51.jpg)

- u_Pattern 是纹理图案采样器，对应下图：

![](../img/2021/1220/52.jpg)

之后，通过采样器找到原始图片和纹理图案的片元后，便可以对其进行运算：

```js
vec4 o=texture2D(u_Sampler,v_Pin);
vec4 p=texture2D(u_Pattern,v_Pin);
gl_FragColor=p*o;
```

上面的 p\*o 便是在对片元做分量相乘的运算，这种算法会让原始图片的亮度变暗，有点类似于 ps 里的正片叠底。

![](../img/2021/1220/53.png)

举个例子说一下片元相乘的逻辑。

已知：

- 原始图像片元 o(ox,oy,oz,ow)
- 纹理图案片元 p(px,py,pz,pw)

求：p\*o

解：

```js
p * o = (px * ox, py * oy, pz * oz, pw * ow);
```

通过此例可知：因为片元分量的值域为[0,1]，所以 p\*o 的亮度小于等于 p 和 o

- 当 p=(1,1,1,1) 时，p\*o=o

```js
p * o = (1 * ox, 1 * oy, 1 * oz, 1 * ow);
p * o = (ox, oy, oz, ow);
```

- 当 p=(0,0,0,0) 时，p\*o=(0,0,0,0)

#### 4-3 纹理混合

纹理混合就是按照一定比例，将第一张图像合到另一张图像上，这类似于 ps 里的透明度合成。

直接看一下纹理在片元着色里的合成方法。

```js
<script id="fragmentShader" type="x-shader/x-fragment">  
  precision mediump float;
  uniform sampler2D u_Sampler;
  uniform sampler2D u_Pattern;
  varying vec2 v_Pin;
  void main(){
    vec4 o=texture2D(u_Sampler,v_Pin);
    vec4 p=texture2D(u_Pattern,v_Pin);
    gl_FragColor=mix(o,p,1.0);
  }
</script>
```

上面的 mix() 方法便是按照比例对两个纹理的合成方法。

mix() 方法的返回数据类型会因其合成对象的不同而不同。

其规则如下：

```js
mix(m, n, a) = m + (n - m) * a;
```

例 1：

- m=3
- n=5
- a=0.5

求：mix(m,n,a)

解：

```js
mix(m, n, a) = 3 + (5 - 3) * 0.5;
mix(m, n, a) = 3 + 2 * 0.5;
mix(m, n, a) = 4;
```

例 2：

- m=(1,2,3)
- n=(3,4,5)
- a=0.5

求：mix(m,n,a)

解：

```js
mix(m, n, a) = (1 + (3 - 1) * 0.5, 2 + (4 - 2) * 0.5, 3 + (5 - 3) * 0.5);
mix(m, n, a) = (2, 3, 4);
```

简单总结一下 mix(m,n,a) 方法的特性：

- 当 a=0 时，mix(m,n,a)=m
- 当 a=1 时，mix(m,n,a)=n

参考地址：https://www.khronos.org/registry/OpenGL-Refpages/gl4/

利用纹理混合，我们可以实现转场动画。

### 5.跨域图像做贴图

这里要说的跨域图像问题，并不单是 webgl 问题，也是 canvas 2d 里的问题。

1. img 标签与跨域图像

用 img 标签显示跨域图像的时候，只能将图像展示给用户，但并不能获取图像中的数据。

```js
<img src="https://xxx/xxx.png'">
```

不能通过 img 标签获取图像数据，是浏览器出于安全考虑的，因为有的图像里可能会含有验证码、签名、或者其它不可告人的东东，这种数据是不能随意被别人获取的。

2. 获取图像数据

若图像是同域的，下面的方法是没问题的：

```js
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

const img = new Image();
img.src = "https://xxx/xxx.png";

img.onload = function() {
  const { width, height } = canvas;
  ctx.drawImage(img, 0, 0);
  ctx.getImageData(0, 0, width, height);
};
```

若图像是跨域的，那就会报错：

```js
Failed to execute 'getImageData' on 'CanvasRenderingContext2D': The canvas has been tainted by cross-origin data.
```

用 webgl 获取跨域图像数据时，也会报错：

```js
const image = new Image();
image.src = "https://xxx/xxx.png";
image.onload = function() {
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, image);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  const u_Sampler = gl.getUniformLocation(gl.program, "u_Sampler");
  gl.uniform1i(u_Sampler, 0);
  render();
};
```

错误信息：

```js
Failed to execute 'texImage2D' on 'WebGLRenderingContext': The image element contains cross-origin data, and may not be loaded.
```

3. CORS 跨域

CORS 是 Cross Origin Resource Sharing 的简写，译作跨域资源共享。

CORS 是一种网页向图像服务器请求使用图像许可的方式。

CORS 的实现过程如下：

1.先让服务器向其它域名放权，比如 Apache 服务器需要这样设置：

```js
Header set Access-Control-Allow-Origin "*"
```

上面代码的意思就是允许其它域名的网页跨域获取自己服务端的资源。

上面的\* 是允许所有域名获取其服务端资源。

我们也可以写具体的域名，从而允许特定域名获取其服务端资源。

2.在网页里，通过特定的方法告诉服务端，我需要跨域获取你的资源。

```js
const image = new Image();
image.src = "https://xxx/xxx.png";
image.setAttribute("crossOrigin", "Anonymous");
```

有了上面 crossOrigin 属性的设置，无论是在 canvas 2d 里使用此图像源，还是在 webgl 里使用此图像源，都不会报错。

crossOrigin 接收的值有三种：

- undefined 是默认值，表示不需要向其它域名的服务器请求资源共享
- anonymous 向其它域名的服务器请求资源共享，但不需要向其发送任何信息
- use-credentials 向其它域名的服务器请求资源共享，并发送 cookies 等信息，服务器会通过这些信息决定是否授权

### 6.视频贴图

之前使用 texImage2D 方法将 Image 图像源装进了纹理对象里：

```js
gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, image);
```

也可以把上面的 image 换成 video 对象

1. 正常建立纹理对象，并设置其相关属性

```js
gl.activeTexture(gl.TEXTURE0);
const texture = gl.createTexture();
gl.bindTexture(gl.TEXTURE_2D, texture);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
```

2. 获取采样器对应的 uniform 变量，并将纹理单元号赋给它

```js
const u_Sampler = gl.getUniformLocation(gl.program, "u_Sampler");
gl.uniform1i(u_Sampler, 0);
```

3. 建立 video 对象，并播放

```js
const video = document.createElement("video");
video.src = "http://img.yxyy.name/ripples.mp4";
video.autoplay = true;
video.muted = true;
video.loop = true;
video.setAttribute("crossOrigin", "Anonymous");
video.play();
video.addEventListener("playing", () => {
  ani();
});
```

4. 在 video 对象播放时，向纹理对象连续写入 video

```js
function render() {
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, video);
  gl.clear(gl.COLOR_BUFFER_BIT);
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, sourceSize);
  requestAnimationFrame(render);
}
```
